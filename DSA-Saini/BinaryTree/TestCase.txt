Bottom Up means- What last node will return and based on that second last will do the calculation.

// Define the TreeNode class
function TreeNode(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
}

//Print Binary TreeNode//Test cases
function printTree(root) {
    if (!root) return console.log("Empty Tree");

    let queue = [root];
    let result = [];

    while (queue.length > 0) {
        let curr = queue.shift();
        if (curr) {
            result.push(curr.val);
            queue.push(curr.left);
            queue.push(curr.right);
        } else {
            result.push(null);
        }
    }

    // Trim trailing nulls
    while (result[result.length - 1] === null) result.pop();
    console.log(result);
}


//Test cases
function TreeNode(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
}

// Test 1: subRoot is a valid subtree
let root1 = new TreeNode(3,
    new TreeNode(4, new TreeNode(1), new TreeNode(2)),
    new TreeNode(5)
);
let subRoot1 = new TreeNode(4, new TreeNode(1), new TreeNode(2));
console.log("Test 1:", isSubtree(root1, subRoot1)); // true

// Test 2: subRoot is not a subtree
let root2 = new TreeNode(3,
    new TreeNode(4, new TreeNode(1), new TreeNode(2, new TreeNode(0))),
    new TreeNode(5)
);
let subRoot2 = new TreeNode(4, new TreeNode(1), new TreeNode(2));
console.log("Test 2:", isSubtree(root2, subRoot2)); // false

// Test 3: subRoot is exactly the same as root
let root3 = new TreeNode(1, new TreeNode(2), new TreeNode(3));
let subRoot3 = new TreeNode(1, new TreeNode(2), new TreeNode(3));
console.log("Test 3:", isSubtree(root3, subRoot3)); // true

// Test 4: subRoot is null
let root4 = new TreeNode(1);
console.log("Test 4:", isSubtree(root4, null)); // false

// Test 5: root is null
console.log("Test 5:", isSubtree(null, new TreeNode(1))); // false

// Test 6: both null
console.log("Test 6:", isSubtree(null, null)); // false (by problem definition)